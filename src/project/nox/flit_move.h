/* NoX (NoC Simulator)
 *
 * Dept. of Computer Science & Engineering, Pennsylvania State University.
 * All Rights Reserved.
 *  
 * 1. License     
 * NoX is distributed free of charge for academic, educational, noncommercial 
 * research purposes as long as this notice in its entirety is preserved in
 * every file included in this package.
 * All commercial use of this program requires separate licence. Contact the
 * author for details.
 * 
 * 2. All the publications that used the simulation results generated by the 
 * NoX should notify the author of the publication information and put 
 * following reference.
 *
 *  http://www.cse.psu.edu/~dpark/nox/
 * 
 * 3. Modification of the source code is permitted and encouraged as long as 
 * it follows the terms described in this copyright notice.
 *
 * 4. The author is not responsible for any problems caused by possible errors
 * of the NoX package. Therefore, users should verify the simulation result
 * before using it in their publication.
 *
 * Dept. of Computer Science & Engineering, Pennsylvania State University.
 * Contact: dpark@cse.psu.edu 
 * 
 * 6. If problems are found with the NoX package, please send an email to the
 * author for discussion and correction.

 */

/* Update History
 *
 *
 */


#ifndef FLIT_MOVE_H
#define FLIT_MOVE_H

#include "flit.h"

typedef struct mail_box_item
{
  struct mail_box_item *next;
  flit_t *ptr;
} mbox_item_t;

// Here, the number of messages sent or received are stored in the num_diff.
// Then, at the end of each iteration, this value is added to the num_msg.
// Otherwise, a message can be passed to several pipeline stages in a single cycle.
typedef struct mail_box
{
  struct mail_box_item *next;
  struct mail_box_item *tail;
  int num_msg;  // # of messages at the end of each cycle.
  int num_diff; // # of messages sent or received during one cycle.
} mbox_t;

void send_flit(mbox_t *dest, flit_t **flit_ptr);
void recv_flit(mbox_t *src,  flit_t **flit_ptr);
void read_flit(mbox_t *src,  flit_t **flit_ptr);
int  msg_cnt(mbox_t *mbox);
void update_cnt(mbox_t *mbox);
void print_mbox(mbox_t *mbox);
void mark_mbox(int local, int nn, mbox_t *mbox, int *marking_counter);
void mbox_update_icycles( mbox_t *mbox, short id, short type, int);
bool is_mbox_atomic( mbox_t *mbox);
bool mbox_head_frame_present(mbox_t *mbox);
#endif
