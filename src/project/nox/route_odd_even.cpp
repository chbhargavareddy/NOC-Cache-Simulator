/* NoX (NoC Simulator)
 *
 * Dept. of Computer Science & Engineering, Pennsylvania State University.
 * All Rights Reserved.
 *  
 * 1. License     
 * NoX is distributed free of charge for academic, educational, noncommercial 
 * research purposes as long as this notice in its entirety is preserved in
 * every file included in this package.
 * All commercial use of this program requires separate licence. Contact the
 * author for details.
 * 
 * 2. All the publications that used the simulation results generated by the 
 * NoX should notify the author of the publication information and put 
 * following reference.
 *
 *  http://www.cse.psu.edu/~dpark/nox/
 * 
 * 3. Modification of the source code is permitted and encouraged as long as 
 * it follows the terms described in this copyright notice.
 *
 * 4. The author is not responsible for any problems caused by possible errors
 * of the NoX package. Therefore, users should verify the simulation result
 * before using it in their publication.
 *
 * Dept. of Computer Science & Engineering, Pennsylvania State University.
 * Contact: dpark@cse.psu.edu 
 * 
 * 6. If problems are found with the NoX package, please send an email to the
 * author for discussion and correction.

 */

/* Update History
 *
 *
 */

/* ROUTE_WEST_FIRST.C - Implements the Partially Adaptive West-First routing algorithm */

#include "main.h"

#include "router_common.h"

#include "route_odd_even.h"

#include "shared.h"

void odd_even_route(int cn, int dn, int pc, int vc, int * dest_pc, int * dest_vc)
/* returns the pc to go out */
{
  int credit[MAX_PC - MAX_NIC_PC], best_vc[MAX_PC - MAX_NIC_PC]; // number of available buffer
  int is_blocked[4]; // blocking state
  int cx, cy, dx, dy, hx, hy; // hold the coordinates of the current node 
  int xdir, ydir, xdist, ydist, cur_dir; // the direction the packet is moving in 
  int credits_north = 0;
  int credits_south = 0;
  int credits_west = 0;
  int credits_east = 0;
  int cur_dir1;
  int cur_dir2;

  // Calculate cur and dest node coordinates 
  calc_coord(cn, & cx, & cy);
  calc_coord(dn, & dx, & dy);
  hx = NUM_COLS / 2;
  hy = NUM_ROWS / 2;
  get_best_credit(cn, credit, best_vc); // Check the maximum number of available buffer of VCs in a PC.
  get_blocked(cn, is_blocked); // Calculate blocked signals 
  cur_dir = -1;

  // Calculate xdir, ydir, xdist, ydist
  if (topology == MESH) {
    xdir = (dx > cx) ? RIGHT : LEFT;
    ydir = (dy > cy) ? UP : DOWN;
    xdist = (dx > cx) ? dx - cx : cx - dx;
    ydist = (dy > cy) ? dy - cy : cy - dy;
  } // if MESH
  else if (topology == TORUS) {
    xdir = (dx > cx) ? ((dx - cx <= hx) ? RIGHT : LEFT) : ((cx - dx < hx) ? LEFT : RIGHT);
    ydir = (dy > cy) ? ((dy - cy <= hy) ? UP : DOWN) : ((cy - dy < hy) ? DOWN : UP);
    xdist = (dx > cx) ? ((dx - cx <= hx) ? dx - cx : NUM_COLS - (dx - cx)) : ((cx - dx < hx) ? cx - dx : NUM_COLS - (cx - dx));
    ydist = (dy > cy) ? ((dy - cy <= hy) ? dy - cy : NUM_COLS - (dy - cy)) : ((cy - dy < hy) ? cy - dy : NUM_COLS - (cy - dy));
  } // if TORUS

  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // Now, make routing decision.
  int north_direction = 0;
  int south_direction = 0;
  int east_direction = 0;
  int west_direction = 0;
  if (dx == cx && dy==cy) {
    * dest_pc = THIS;* dest_vc = vc;
    return;
  } // Reached the destination

  if (xdist == 0) {
    if (dy > cy) {
      north_direction = 1;
    } else {
      south_direction = 1;
    }
  } else {
    if (dx > cx) {
      if (ydist == 0) {
        east_direction = 1;
      } else {
        if (cx % 2 != 0) {
          if (dy > cy) {
            north_direction = 1;
          } else {
            south_direction = 1;
          }
        }
        if (dx % 2 != 0 || xdist != 1) {
          east_direction = 1;
        }
      }
    } else {
      west_direction = 1;
      if (cx % 2 == 0) {
	
        if (dy > cy) {
          north_direction = 1;
        } else {
          south_direction = 1;
        }
	}
      }
  }
  if (north_direction == 1) {
    credits_north = credit[UP];
  }
  if (south_direction == 1) {
    credits_south = credit[DOWN];
  }
  if (east_direction == 1) {
    credits_east = credit[RIGHT];
  }
  if (west_direction == 1) {
    credits_west = credit[LEFT];
  }
  cur_dir1 = (credits_north > credits_south) ? credits_north : credits_south;
  cur_dir2 = (credits_west > credits_east) ? credits_west : credits_east;
  cur_dir = (cur_dir1 > cur_dir2) ? ((credits_north > credits_south)? UP : DOWN):((credits_west > credits_east)? LEFT : RIGHT);//cur_dir1 : cur_dir2;
  * dest_pc = cur_dir;*dest_vc = (best_vc[cur_dir] != -1)? best_vc[cur_dir] : vc;
  return;
}